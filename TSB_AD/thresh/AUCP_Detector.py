# -*- coding: utf-8 -*-
# Author: Konstantinos Gallos <kggallos@gmail.com>
# License: Apache-2.0 License
"""
This code is adapted from [pythresh] by [KulikDM]
Original source: [https://github.com/KulikDM/pythresh]
"""

import pandas as pd
import numpy as np
import argparse, time
from sklearn.metrics import auc

from TSB_AD.evaluation.metrics import get_metrics
from TSB_AD.utils.slidingWindows import find_length_rank

from .thresholding_utils import check_scores, normalize, gen_kde

class AUCP():
    r"""AUCP class for Area Under Curve Precentage thresholder.

       Use the area under the curve to evaluate a non-parametric means
       to threshold scores generated by the decision_scores where outliers
       are set to any value beyond where the auc of the kde is less
       than the (mean + abs(mean-median)) percent of the total kde auc.
       See :cite:`ren2018aucp` for details

        Parameters
        ----------
        random_state : int, optional (default=1234)
            Random seed for the random number generators of the thresholders.
            Can also be set to None.

        Attributes
        ----------
        threshold_ : float
            The threshold value that separates inliers from outliers.

        decision_scores_: ndarray of shape (n_samples,) #TODO, needs to be removed?
            Not actually used, present for API consistency by convention.
            It contains 0s and 1s because this is a thresholding method.

       Notes
       -----

       The area under the curve (AUC) is defined as follows:

       .. math::

          AUC = \mathrm{lim}_{x\rightarrow\inf} \sum_{i=1}^{n} f(x) \delta x \mathrm{,}

       where :math:`f(x)` is the curve and :math:`\delta x` is the incremental step size
       of the rectangles whose areas will be summed up. The AUCP method generates a
       curve using the pdf of the normalized decision scores over a range of 0-1.
       This is done with a kernel density estimation. The incremental size step is
       :math:`1/2n`, with :math:`n` being the number of points of the decision scores.

       The AUC is continuously calculated in steps from the left to right of the data
       range starting from 0. The stopping limit is set to
       :math:`\mathrm{lim} = \bar{x} + \lvert \bar{x}-\tilde{x} \rvert`, where :math:`\bar{x}`
       is the mean decision score, and :math:`\tilde{x}` is the median decision score.

       The first AUC that is greater than the total AUC of the pdf multiplied by the
       :math:`\mathrm{lim}` is set as the threshold between inliers and outliers.

    """

    def __init__(self, random_state=1234, normalize=True):
        self.random_state = random_state
        self.normalize = normalize

    def fit(self, X, y=None):
        """Fit detector. y is ignored in unsupervised methods.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features)
            The input samples.

        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        self : object
            Fitted estimator.
        """
        pass


    def decision_function(self, X):
        """    
        Not used, present for API consistency by convention.
        """
        pass
        
    def predict(self, X):
        """
        Predict anomalies in a batch of data points.

        Parameters
        ----------
        X : numpy array of shape (n_samples,)
            The input data points.

        Returns
        -------
        preds : numpy array of shape (n_samples,)
            Predictions (1 for anomaly, 0 for normal).
        """
        n_samples, n_features = X.shape

        X = check_scores(X, random_state=self.random_state)

        if self.normalize: X = normalize(X)

        # Generate KDE
        val, dat_range = gen_kde(X, 0, 1, len(X)*2)
        val = normalize(val)

        # Get the total area under the curve
        tot_area = auc(dat_range, val)

        # Get area percentage limit
        mean = np.mean(X)
        perc = mean+abs(mean-np.median(X))

        # Apply the limit to where the area is less than that limit percentage
        # of the total area under the curve
        limit = 1
        for i in range(len(dat_range)):

            splt_area = auc(dat_range[i:], val[i:])

            if splt_area < perc*tot_area:
                limit = dat_range[i]
                break

        self.threshold_ = limit

        preds = np.zeros(n_samples, dtype=int)
        preds[X >= self.threshold_] = 1

        return preds


if __name__ == '__main__':

    Start_T = time.time()
    ## ArgumentParser
    parser = argparse.ArgumentParser(description='Running AUCP')
    parser.add_argument('--filename', type=str, default='001_NAB_id_1_Facility_tr_1007_1st_2014.csv')
    parser.add_argument('--data_direc', type=str, default='Datasets/TSB-AD-U/')
    parser.add_argument('--AD_Name', type=str, default='AUCP')

    # multivariate
    # parser.add_argument('--filename', type=str, default='057_SMD_id_1_Facility_tr_4529_1st_4629.csv')
    # parser.add_argument('--data_direc', type=str, default='Datasets/TSB-AD-M/')
    args = parser.parse_args()

    Custom_AD_HP = {
        'random_state': 1234,   # not related to method itself, but to formatting input
    }

    df = pd.read_csv(args.data_direc + args.filename).dropna()
    data = df.iloc[:, 0:-1].values.astype(float)
    label = df['Label'].astype(int).to_numpy()
    print('data: ', data.shape)
    print('label: ', label.shape)

    slidingWindow = find_length_rank(data, rank=1)

    clf = AUCP()
    output = clf.predict(data)
    pred = output   # output has already the predictions
    evaluation_result = get_metrics(output, label, slidingWindow=slidingWindow, pred=pred)
    print('Evaluation Result: ', evaluation_result)
